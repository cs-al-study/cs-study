# 정렬 알고리즘

## 분류

- 안전 정렬(Stable Sort) : 중복된 값을 입력 순서와 동일하게 정렬하는 알고리즘
- 불안전 정렬(Unstable Sort) : 중복된 값을 입력 순서와 동일하다는 보장 없이 정렬하는 알고리즘

## 정렬 장소에 따른 분류

- 내부 정렬(internal sort) : 정렬할 자료를 메인 메모리에 올려서 정렬하는 방식, 속도가 빠르지만 메인 메모리 용량에 따라 정렬할 수 있는 양이 제한적
- 외부 정렬(external sort) : 정렬할 자료를 보조 기억장치에서 정렬, 속도는 떨어지지만 대용량 정렬 가능

## 실행 방법에 따른 분류

![image](https://user-images.githubusercontent.com/92436863/227881189-06ac3c6c-aa4b-422f-a8a4-39ed97291490.png)

- 단순(구현 간단)하지만 비효율적인 방법
    - 삽입, 선택, 버블
- 복잡하지만 효율적인 방법
    - 퀵, 힙, 합명, 기수

### 버블 정렬(Bubble Sort)

- 배열의 첫 원소부터 순차적으로 현재 원소가 다음 원소 값보다 크면 두 원소를 바꿈
- 위와 같은 방법을 N회전 수행하면 정렬 완료

#### 시간복잡도
(n-1)(회전1) + (n-2)(회전2) + ... + 2 + 1 => n(n-1)/2 이므로 O(n^2)
#### 공간복잡도
- 주어진 배열안에서 교환을 하므로(동적으로 메모리 추가 x) O(n)

### 선택 정렬(Selection Sort)

- 배열을 선형 탐색하며 가장 작은 원소를 맨 앞의 원소와 교체
- 그 다음 두번째로 작은 원소를 찾아 교체
- 위와 같은 작업을 정렬될 때까지 반복

#### 시간복잡도
n(n-1)/2 이므로 O(n^2)
#### 공간복잡도
- 주어진 배열안에서 교환을 하므로(동적으로 메모리 추가 x) O(n)

### 삽입 정렬(Insertion Sort)

- 배열 탐색후 가장 작은 원소를 맨 앞에 삽입, 그다음 두번째로 작은 원소를 그 뒤에 삽입
- 위와 같은 작업을 정렬 될 때까지 반복

#### 시간복잡도
O(n^2)로 동일 / 하지만 거의 정렬이 되어있는 최적의경우 O(n)에 가깝다
#### 공간복잡도
O(n)

### 병합 정렬(Merge Sort)

- 분할-정복 알고리즘 사용
    - 재귀호출을 통해 구현
    - 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할
    - 정복(Conquer): 부분 배열을 정렬. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법 적용
    - 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병
        - 이때 두 배열을 비교하여 정렬하는 작업을 함


![image](https://user-images.githubusercontent.com/92436863/227889951-f9fb811a-dca0-42f8-93ee-f1aded057ef1.png)

#### 시간복잡도
=> O(NlogN)
#### 공간복잡도
=> O(2n)  // 임시 배열이나 벡터가 필요하다

연결리스트로 구성하면, 링크 인텍스만 변경되므로 제자리 정렬로 구현 가능

### 퀵 정렬(Quick Sort)
- 무작위로 선정된 원소(pivot)을 사용하여 배열을 분할
- 선정된 원소보다 작은 원소들은 앞에, 큰 원소들은 뒤에 보낸다. => 분할
- 반복해서 분할해 나가면 정렬된 상태에 도달한다.

#### 시간복잡도
평균 O(N*logN) // 원소(pivot)이 중간값에 가까운 값이 되리라는 보장이 없기 때문에 최악의 경우 O(n^2)

### 힙 정렬(Heap Sort)
- Heap 자료구조를 이용하여 정렬
    - 정렬해야할 n개의 요소들로 최대 힙(완전 이진 트리 형태)를 만든다
    - 한 번에 하나씩 요소를 힙에서 꺼내어서 배열의 뒤부터 저장
    - 삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬되게 된다.