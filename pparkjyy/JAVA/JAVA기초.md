# JAVA 기초

<br>

## 제어자
- 클래스, 변수, 메서드의 선언부에 사용되어 부가적인 의미를 부여

### 일반제어자
-  **static, final, abstract**,native, transient, synchronized, volatile, strictfp

### 접근제어자
멤버 또는 클래스에 사용되어 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할

  | 제어자 | 같은 클래스 |  같은 패키지 | 자손 클래스 | 전체 |
  | --- | --- | --- | --- | --- |
  | public | O | O | O | O |
  | protected | O | O | O |  |
  | default | O | O |  |  |
  | private | O |  |  |  |

- 접근 범위 : private < default < protected < public 순서

## 클래스, 객체, 인스턴스 차이

### 클래스

- 객체를 구현하기 위한 설계도
- 객체의 상태를 나타내는 필드와 객체의 행동을 나타내는 메서드와 객체를 초기화하여 생성하는 생성자로 구성

### 객체

- 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 말함
- 클래스에 선언된 모양 그대로 생성된 실체

### 인스턴스

- 클래스에 따라 객체를 실체화한 것으로 실제로 메모리에 할당된 실체
- 객체를 소프트웨어에 실체화 하면 그것을 '인스턴스'라고 부른다.

## Overloading vs Overriding

### 오버로딩

- 같은 이름의 메서드 여러개를 가지면서 매개변수의 유형과 개수가 다르도록 하는것
- 특징
    - 메서드 이름이 같아야 한다
    - 매개변수의 개수나 타입이 달라야한다.
    - 오버로딩은 매개변수에 의해서만 구별될 수 있으므로 반환타입은 오버로딩을 구현하는데 영향을 주지 못한다.

### 오버라이딩

- 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용
- 특징
    - 메서드의 선언부는 상위 클래스와 일치해야한다 (메서드 이름, 매개변수, 반환타입)
    - 접근 제어자는 상위 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
    - 예외는 상위 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
    - 인스턴스 메서드 <-> static 메서드 로 변경할 수 없다.


## Primitive type vs Reference type

### Primitive type(원시 타입)
- 변수에 값 자체를 저장
- 비객체 타입이기 때문에 null 값을 가질 수 없다.
- 실제 값을 저장하는 공간으로, stack 메모리에 저장된다.
- 컴파일 시점에 데이터의 표현 범위를 벗어나면 컴파일 에러가 발생
- ex) boolean, byte, short, int, long, float, double, char
- 참조 타입에 비해 더 빠르고 메모리 효율이 좋다.

### Reference type (참조 타입)
- 메모리상에 객체가 있는 위치를 저장
- 원시 타입을 제외한 타입들 모두 참조 타입이다.
- 빈 객체를 의미하는 null이 존재
- 값이 저장되어 있는 곳의 주소값을 저장하는 공간으로 heap 메모리에 저장
- ex) array, enumeration, class, interface

**성능과 메모리에 장점이 있는 원시 타입을 먼저 고려한 후, NULL을 다뤄야 하거나, 제네릭 타입에서 사용되어야 한다면 참조타입 사용**


## Call by Reference vs Call by Value

### Call by Value
- 함수에서 값을 복사해 전달하는 방식으로, 인자로 전달되는 변수를 함수의 매개변수에 복사한다.
- 함수의 매개변수는 인자로 전달한 변수와는 별개의 변수가 되며 매개변수를 변경해도 원래의 변수에는 영향을 미치지 않는다.
    - 복사된 인자는 함수 안에서 지역적으로 사용되는 local value의 특성을 가진다.

### Call by Reference

- 함수에서 주소값을 전달하는 방식으로, 함수 호출시 인자로 전달되는 변수의 레퍼런스를 전달한다. (해당 변수를 가르킨다.)
- 함수 안에서 인자의 값이 변경되면, 인자로 전달된 객체의 값도 함께 변경된다.

### JAVA 에서의 Call by Value & Reference
- java는 오직 Call by Value 로만 동작한다.
    - 이유
    - call by reference는 원본의 주소값을 전달하므로, 원본을 변경할 수 있다. 자바에는 포인터 같은 변수의 주소값을 추철 및 저장한는 기능이 없다.

## Wrapper Class
- 8가지의 기본타입을 객체로 표현한 것

![image](https://user-images.githubusercontent.com/92436863/222370798-8bf707f1-45e0-43d6-8da9-04f9217bae79.png)


- 사용이유
    - 래퍼 클래스는 기본 데이터 타입을 Object로 변환할 수 있다. 메소드에 전달된 인수를 수정하려는 경우 오브젝트가 필요하다.
    - java.util 패키지의 클래스는 객체만 처리하므로 Wrapper class는 이 경우에도 도움이 된다.
    - ArrayList 등과 같은 Collection 프레임 워크의 데이터 구조는 기본 타입이 아닌 객체만 저장하게 되고 Wrapper class를 사용하여 자동 박싱과 언박싱이 일어나다.
    - 멀티스레딩에서 동기화를 지원하려면 객체가 필요하다.

## interface vs abstract class

### abstract class (추상 클래스)
- 부모 클래스에서 필요한 대부분의 기능을 구현하고, 자식 클래스가 재정의할 부분은 추상 메소드로 선언하는 것
    - 상속 + 다형성을 통해 기능을 확장하는것
    - 클래스와 메소드에 abstract 제어자를 붙여준다
- 다중 extends 불가능
- 필드값과 일반 메소드를 가질 수 있다.

### interface (인터페이스)
- 인터페이스를 implements하는 여러 클래스들의 메소드 구현을 강제하기 위해 사용한다.
- 다중 implements가 가능하다.
- java 8 부터 default 메소드로 기본 구현가능



![image](https://user-images.githubusercontent.com/92436863/223038084-9b7bd02c-7348-41f1-9166-9bb9659fbec5.png)

## Error와 Exception

- Error
    - 시스펨에 비정상적인 상황이 발생했을 경우 ex) OutofMemoryError, StackOverflowError
    - 개발자가 예측하기도 쉽지 않고 처리할 수 있는 방법도 없다.

- Exception
    - 개발자의 실수로 예기치 않은 상황이 발생했을 때 ex) 배열범위벗어남, 값 null이 참조변수 참조, 존재하지 않는 파일 이름 ..
    - 체크 예외(Checked Exception), 언체크 예외(Unchecked Exeption)로 나눌 수 있음

## Checked Exception vs UnChecked Exception

- Checked Exception
    - 실행 전 발생할 수 있는 에러 -> 컴파일 시점에서 발생
    - 반드시 예외처리를 해야함
    - ex) IOException, SQLException .. 

- Unchecked Exception
    - 실행 중 발생할 수 있는 에러 -> 런타임 시점에서 발생
    - RuntimeException을 상속
    - ex) NullPointerException, ClassCastException ..

## static

- 일반적인 변수는 jvm 힙 영역에 저장되는 반면, static 변수는 메소드 영역에 저장된다.
- 메소드 영역은 가비지 컬렉터가 동작하지 않으므로, 프로그램 종료시까지 할당된 채로 존재한다.
    - 모든 인스턴스가 같은 값을 유지해야할 때 사용
    - 유틸 클래스처럼 인스턴스를 생성할 필요가 없는 클래스에서 사용. (할당없이 빠른 호출)

## final

- 객체를 단 한번만 할당하는 제어자. 두번 할당하면 컴파일 오류 발생
- 변수, 메소드, 클래스에 적용할 수 있음
    - 변수는 상수처럼 고정하여 사용
    - 메소드는 Overriding 불가
    - 클래스는 상속 불가

## generic

- 객체 생성 시점에 타입을 결정하여, 유연한 설계를 가능하게 하는 기능
- 컴파일시 타입을 미리 체크한다
- ex) Collection 라이브러리


## Lambda & Stream

### Lambda

- 익명함수를 뜻하고, 그 자체로 일급객체가 되며 매개변수처럼 사용할 수 있다.
- 람다함수 내부에서는 외부 지역 변수를 사용할 수 없음
    - but `final` or `Effectively final` 변수는 사용할 수 있다
    - 람다 실행시 임시 스레드가 따로 생성되므로, 스택영역을 공유하지 않기 때문
    - `final` 변수 또한 공유하는 것이 아닌 람다식에서 '복사'하여 사용하는 것.

### Stream

- 컬렉션이나 배열의 요소를 내부적으로 반복 처리하는 기능
- 원본 객체를 변경하지 않는다.
    - 원본 객체를 참조하여 어떠한 새로운 결과를 도출해 내는것
- 일회용으로만 사용가능하다
    - stream 객체는 한번 선언하면 재사용이 불가능하다.
- 3가지 단계를 거쳐 사용된다
    - stream 생성
    - 중개 연산 : filter-map API를 사용하여 지연(lazy) 연산을 통해 선응을 최적화함
    - 최종 연산 : 이때 실제로 연산이 이루어지며, 지연됐던 모든 연산을 처리한다
- lambda와 stream의 장점
    - 불필요한 코드를 줄여 가독성을 좋게한다.
    - 내부 연산으로 병렬 처리가 가능하다
- 단점
    - 디버깅이 힘들다
    - 예외처리도 힘들다.

## Reflection & Dynamic Proxy

### Reflection
- 객체를 통해 클래스의 정보를 분석해 내는 프로그램 기법
- 실행중인 자바프로그램 내부를 검사하고 내부의 속성을 수정할 수 있도록 한다.

#### 장점
- 런타임 시점에서 클래스의 인스턴스를 생성하고, 접근 제어자와 관계 없이 필드와 메소드에 접근하여 필요한 작업을 수행할 수 있는 유연성을 가지고 있다.
#### 단점
- 캡슐화를 저해한다
- 런타임 시점에서 인스턴스를 생성하므로 컴파일 시점에서 해당 타입을 체크할 수 없다.
- 런타임 시점에서 인스턴스를 생성하므로 구체적인 동작 흐름을 파악하기 어렵다.
#### 사용방법
- 클래스.class로 가져오기
- 인스턴스.getClass()로 가져오기
- Class.forName("클래스명")으로 가져오기


### Proxy
- 타겟의 기능을 확장하거나 접근을 제어하기 위한 목적으로 사용되는 기법

![image](https://user-images.githubusercontent.com/92436863/223988181-96a13022-f484-48fa-8a28-484ee7d1d9d1.png)

클라이언트가 Subject 인터페이스의 request()를 호출하면 구현클래스인 RealSubject의 request()가 호출된다. 이떄 프록시가 대신 RealSubject의 request()메서드를 호출하고 그 반환값을 클라이언트에게 전달한다.

#### 왜 쓰나
- 흐름제어가 가능하다.
    - 많은 양의 리소스를 필요로하는 상황에서 디비쿼리가 느려짐 이때 프록시객체가 먼저 받은뒤에 흐름을 제어
- 실제 메소드가 호출되기 이전에 필요한 기능을 구현객체 변경없이 추가할 수 있다.
- 캐시 사용 가능