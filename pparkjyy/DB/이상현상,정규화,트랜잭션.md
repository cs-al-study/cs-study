# 이상현상, 정규화, 트랜잭션

<br>

## 이상현상 (Anomaly)

- 테이블 내 데이터들이 불필요하게 중복되어 발생하는 데이터 불일치 현상
- 종류
    - 삽입 이상 : 불필요한 데이터까지 함께 삽입해야 하는 문제
    - 삭제 이상 : 특정 컬럼 데이터를 삭제하고 싶어도 모든 행을 삭제해야하는 문제
    - 갱신 이상 : 특정 컬럼 데이터를 수정하려할때 다른 행까지 모두 수정해야하는 문제

<br>

## 정규화 (Normalization)

- 테이블 간 중복된 데이터를 허용하지 않는 것
    - 무결성 유지
    - DB 저장 효율 증가
- 정규화를 통해 이상현상을 해결할 수 있음

### 정규화 과정

- 제 1 정규형 : 도메인은 모두 원자값
- 제 2 정규형 : 부분 함수 종속 제거
- 제 3 정규형 : 이행적 함수 종속 제거
- BCNF : 결정자 중 후보키가 아닌 것들은 제거
- 제 4 정규형 : 다치 종속 제거
- 제 5 정규형 : 조인 종속성 제거


### 반 정규화
- 정규화된 개체/속성/관계를 단순화하는 기법
    - 성능 & 관리 효율성 증가
    - 일관성 & 무관성 감소



## 트랜잭션

- 데이터베이스의 상태를 변화시키키기 위해 수행하는 작업의 단위
- 한꺼번에 수행되어야 할 일련의 작업
- 하나의 트랜잭션은 커밋되거나 롤백된다
    - `Commit` : 트랜잭션 결과를 DB에 반영
    - `Rollback` : 오류가 한번이라도 났을 경우 해당 트랜잭션 종료 or 재시작 

### 특징

- **원자성 (Atomicity)**
    - 트랜잭션내 작업은 모두 반영되거나 모두 반영되지 않아야 한다.
    - 트랜잭션 내 작업 중 하나라도 오류 발생시 트랜잭션 전부가 취소되어야 한다
- **일관성 (Consistency)**
    - 트랜잭션 결과 데이터베이스는 언제나 일관성 있는 상태여야 한다.
    - 트랜잭션 도중 수정된 상태를 참조하지 않고, 수정 전 상태를 참조함
- **독립성 (Isolation)**
    - 둘 이상의 트랜잭션이 동시 실행되는 경우 서로의 연산에 끼어들 수 없다
    - 수행중인 트랜잭션은 완전히 완료될때까지 다른 트랜잭션의 결과를 참조할 수 없다.
- **영속성 (Durablility)**
    - 성공적으로 완료된 트랜잭션 결과는 영구적으로 반영되어야 한다.

<br>

## Lock

- 트랜잭션의 순차성을 보장하기 위한 방법
- DB, 테이블, 행 단위로 Lock을 걸수 있으며, 보통 행 단위로 사용함

### 종류

- **공유 락**
    - Shared/Read Lock
    - 읽기 연산만 허용하고 쓰기 연산은 허용하지 않음
    - 한 데이터에 여러개의 공유락이 동시에 걸릴 수 있지만, 배타락은 걸 수 없음
- **배타 락**
    - Exclusive/Write Lock
    - 읽기/쓰기 연산 모두 금지
    - 한 데이터에 배타락 하나만 걸 수 있음

### Blocking

<img width="500" src="https://user-images.githubusercontent.com/71180414/153120858-03ff8a7e-0ca6-4331-8943-08c2e5b3fff1.png">

- 특정 데이터에 배타 락이 걸려있을 경우 해당 트랜잭션이 완료되기 전까지 해당 데이터 관련 작업이 모두 중단되는 현상
- 블로킹은 성능 저하를 불러오므로 최소화해야함

### DeadLock

<img width="500" src="https://user-images.githubusercontent.com/71180414/153120883-4cbc4d47-363d-4aa0-b9f5-e041fba0f599.png">

- 두 트랜잭션이 각각 데이터에 Lock을 걸어놓아 두 트랜잭션 모두 영원히 작업을 끝내지 못하는 현상
- 교착상태 발생시 DBMS가 한 트랜잭션에 에러를 발생시켜 문제를 해결함
- 해결법
    - 트랜잭션 내 작업 최소화
    - 트랜잭션간 데이터 교차 접근 최소화
    - 데이터 잠금 최소화

<br>

## Lock 전략

- 데이터에 동시 접근하는 상황일 경우, 충돌이 발생하는데 이를 Lock 전략을 통해 해결 가능

### 비관적 락

<img width="500" src="https://user-images.githubusercontent.com/71180414/153122459-2bae8a87-c665-4951-9c1d-c6f74c3dda54.png">

- `REPEATABLE_READ` 이상의 격리 수준에서 사용가능
- 트랜잭션이 시작될때 사용 데이터에 락을 걸어버리는 전략
    - 트랜잭션 충돌을 가정하고 시작함
    - DB에서 제공하는 공유/배타 락을 사용
- 롤백이 쉬우므로 트랜잭션 충돌이 많이 일어나는 상황에서 사용함

### 낙관적 락

<img width="550" src="https://user-images.githubusercontent.com/71180414/153122507-d286c550-48c3-4d82-b769-0dbd382ea673.png">

- 데이터의 변경 버전을 명시하여 데이터 변경 요청에 순서를 부여함, 최초 요청만 인정
- DB 기능을 사용하지 않고 어플리케이션 레벨에서 구현함
    - 트랜잭션 및 Lock 사용 X
    - 따라서 비관적 락보다 성능이 좋음
- 트랜잭션 충돌이 적은 상황에서 사용함

